<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不穿辣条吃秋裤</title>
  
  <subtitle>LeonHuang Blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongtao-huang.github.io/"/>
  <updated>2018-09-29T13:59:08.966Z</updated>
  <id>https://hongtao-huang.github.io/</id>
  
  <author>
    <name>LeonHuang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解jQuery</title>
    <link href="https://hongtao-huang.github.io/%E8%87%AA%E6%88%91%E5%AE%9E%E7%8E%B0jQuery%E6%96%B9%E6%B3%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jQuery/"/>
    <id>https://hongtao-huang.github.io/自我实现jQuery方法深入理解jQuery/</id>
    <published>2018-06-30T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解jQuery"><a href="#深入理解jQuery" class="headerlink" title="深入理解jQuery"></a>深入理解jQuery</h1><h2 id="自我封装jQuery代码"><a href="#自我封装jQuery代码" class="headerlink" title="自我封装jQuery代码"></a>自我封装jQuery代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector) &#123;</span><br><span class="line">  let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &apos;string&apos;) &#123;</span><br><span class="line">    let tmp = document.querySelectorAll(nodeOrSelector);</span><br><span class="line">    for(var i =0; i &lt; tmp.length; i++)&#123;</span><br><span class="line">      nodes[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = i;</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = function(classs) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].classList.add(classs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = function(text)&#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].textContent = text;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.$ = jQuery</span><br><span class="line"></span><br><span class="line">var $div = $(&apos;div&apos;)</span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;222&apos;) // 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure><h2 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a>代码实现过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function(nodeOrSelector)</span><br></pre></td></tr></table></figure><ul><li>一般我们的得到的元素都是一个dom对象，而这个对象最终继承的就是Node接口</li><li>所以可以在 Node.prototype 上添加以上 addClass 及setText 方法</li><li>但是Node.prototype 是一个共有对象，每个人写的程序都不一样， 如果大家都在这里面操作添加删除API  ,   就会出现各种问题</li><li>所以我们可以取一个我们自己喜欢的名字来当作我们简便操作dom树，这个构造函数就不会被别人乱修改啦，而jQuery的作者就取名叫jQuery的</li><li>为了更懒更简便的操作，所以让$ = jQuery</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let nodes = &#123;&#125;</span><br><span class="line">  if (typeof nodeOrSelector === &apos;string&apos;) &#123;</span><br><span class="line">    let tmp = document.querySelectorAll(nodeOrSelector);</span><br><span class="line">    for(var i =0; i &lt; tmp.length; i++)&#123;</span><br><span class="line">      nodes[i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.length = i;</span><br><span class="line">  &#125; else if (nodeOrSelector instanceof Node) &#123;</span><br><span class="line">    nodes = &#123;</span><br><span class="line">      0: nodeOrSelector,</span><br><span class="line">      length: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>因为jQuery 传入的有可能是字符串形式的选择器 或者 节点元素，所以   这段代码实现的功能是</li><li>先创建一个对象</li><li>判断传入的参数是字符串还是dom对象</li><li>如果是字符串就document.querySelectorAll匹配所有符合的选择器的元素，然后改成jQuery形式的对象，也就是我们开始创建的对象，不能直接复制给这个对象，因为匹配得到的对象是NodeList对象，是dom类型对象</li><li>如果是节点元素就直接添加进第一项就好了</li><li>因为jQuery ,$div[0] === div</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nodes.addClass = function(classs) &#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      nodes[i].classList.add(classs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = function(text)&#123;</span><br><span class="line">    for (let i = 0; i &lt; nodes.length; i++) &#123;</span><br><span class="line">        nodes[i].textContent = text;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nodes;</span><br></pre></td></tr></table></figure><ul><li>最后就是给这个要返回的对象添加API啦</li><li>真正的jQuery的API都是封装在jQuery.prototype中，所有的jQuery对象都共用这些API</li><li>这里的nodes就与两个方法之间产生了闭包， 保护了nodes的私有化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.$ = jQuery</span><br><span class="line"></span><br><span class="line">var $div = $(&apos;div&apos;)</span><br><span class="line">$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red</span><br><span class="line">$div.setText(&apos;222&apos;) // 可将所有 div 的 textContent 变为 hi</span><br></pre></td></tr></table></figure><ul><li>为了更方便的操作 用<code>$</code>代替jQuery  ，<code>var $div = $(&#39;div&#39;)</code> 可以 <code>var $div = jQuery(&#39;div&#39;)</code> 也是一样的</li><li>构造函数返回的对象就包含了两个方法，  我们就可以直接调用啦， </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解jQuery&quot;&gt;&lt;a href=&quot;#深入理解jQuery&quot; class=&quot;headerlink&quot; title=&quot;深入理解jQuery&quot;&gt;&lt;/a&gt;深入理解jQuery&lt;/h1&gt;&lt;h2 id=&quot;自我封装jQuery代码&quot;&gt;&lt;a href=&quot;#自我封装jQuer
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础排序" scheme="https://hongtao-huang.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>登陆注册与cookie</title>
    <link href="https://hongtao-huang.github.io/cookie/"/>
    <id>https://hongtao-huang.github.io/cookie/</id>
    <published>2018-06-27T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登陆注册与cookie"><a href="#登陆注册与cookie" class="headerlink" title="登陆注册与cookie"></a>登陆注册与cookie</h1><h2 id="登陆注册流程"><a href="#登陆注册流程" class="headerlink" title="登陆注册流程"></a>登陆注册流程</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ol><li>提供表单输入</li><li>用户提交 发送post请求</li><li>请求数据带有用户的 注册账号 及 密码等</li><li>可以在前端检查处理用户的注册信息是否有问题</li></ol><h4 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h4><ol><li>设置好路由供请求访问</li><li>处理请求信息，将用户发送的数据提取</li><li>可以在后台检查处理用户的注册信息是否有问题，后响应给前端</li><li>在数据中查找，判断注册用户是否存在 </li><li>将用户的正确的注册信息存储进数据库</li><li>响应注册成功</li></ol><h3 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h3><h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><ol><li>提供表单输入</li><li>用户提交 发送post请求</li><li>请求数据带有用户的 登入账号 及 密码等</li></ol><h4 id="后台-1"><a href="#后台-1" class="headerlink" title="后台"></a>后台</h4><ol><li>设置好路由供请求访问</li><li>处理请求信息，将用户发送的数据提取</li><li>检查处理用户登入的信息是否有问题，后响应给前端</li><li>在数据中查找，判断登入用户是否存在并且密码是否正确 </li><li>响应头中set-cookie（设置cookie）</li><li>这时浏览器中会保存这个cookie信息</li><li>响应登入成功</li></ol><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><ol><li>cookie 是有时效性的</li><li>cookie 是保存在那个使用访问的浏览器中的 ，所以换一个浏览器还是需要重新登录，然后设置cookie</li><li>cookie关闭浏览器就删掉了， 但是可以设置不删掉，或者存留时间</li><li>在cookie没有被删除之前，同源域名的申请每一次都会带上这个cookie</li><li>也就是这个请求的请求头中会自动带上这个cookie</li><li>而访问的页面会根据cookie的值来判断是否登陆</li><li>从而给出不同的页面或者相同的页面不一样的使用权限等</li><li>所以cookie是保存用户登陆信息的东西</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;登陆注册与cookie&quot;&gt;&lt;a href=&quot;#登陆注册与cookie&quot; class=&quot;headerlink&quot; title=&quot;登陆注册与cookie&quot;&gt;&lt;/a&gt;登陆注册与cookie&lt;/h1&gt;&lt;h2 id=&quot;登陆注册流程&quot;&gt;&lt;a href=&quot;#登陆注册流程&quot; cla
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="闭包" scheme="https://hongtao-huang.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>call,apply,bind用法</title>
    <link href="https://hongtao-huang.github.io/call,apply,bind%E7%94%A8%E6%B3%95/"/>
    <id>https://hongtao-huang.github.io/call,apply,bind用法/</id>
    <published>2018-05-28T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="call-apply-bind用法"><a href="#call-apply-bind用法" class="headerlink" title="call,apply,bind用法"></a>call,apply,bind用法</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   name: &apos;hht&apos;,</span><br><span class="line">   age : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(obj,&apos;mmd&apos;,18);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fromntpn9mj305i02za9v.jpg" alt=""></p><ul><li>call()方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表).</li><li>call 的第一个参数是指定调用的这个函数的this ，非严格模式下this的值如果是null或者undefine ，那么这个this指向window</li><li>call 第二个以及之后的参数就是我们的arguments的值</li></ul><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   name: &apos;hht&apos;,</span><br><span class="line">   age : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.apply(obj,[&apos;mmd&apos;,18]);</span><br><span class="line">f.apply(obj,&#123;0: &apos;mmd&apos;, 1: 18, length: 2&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frompayhl9j304s03u3yb.jpg" alt=""></p><ul><li>call()方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组, 或伪数组。</li></ul><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   name: &apos;hht&apos;,</span><br><span class="line">   age : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  for(let i = 0; i &lt; 4; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    console.log(arguments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f1Bind = f.bind(obj,&apos;hht&apos;,18);</span><br><span class="line">f1Bind();</span><br><span class="line">f1Bind(1,2);</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fromlqepfyj30au078mx7.jpg" alt=""></p><ul><li>bind 绑定时接受的参数跟 call 一致.</li><li>bind 不会立即调用，它会生成一个新的函数，你想什么时候调就什么时候调。</li><li>bind 绑定好的this不会改变</li><li>bind 绑定时的给的参数会成为这个绑定函数的固定参数，调用这个函数时这几个参数一定会在</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;call-apply-bind用法&quot;&gt;&lt;a href=&quot;#call-apply-bind用法&quot; class=&quot;headerlink&quot; title=&quot;call,apply,bind用法&quot;&gt;&lt;/a&gt;call,apply,bind用法&lt;/h1&gt;&lt;h2 id=&quot;call&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="call apply bind" scheme="https://hongtao-huang.github.io/tags/call-apply-bind/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="https://hongtao-huang.github.io/%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94/"/>
    <id>https://hongtao-huang.github.io/什么是闭包-闭包的用途/</id>
    <published>2018-05-27T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function 函数()&#123;</span><br><span class="line">    var 变量  = 1；</span><br><span class="line">    function 内部函数()&#123;</span><br><span class="line">        console.log(变量);</span><br><span class="line">    &#125;</span><br><span class="line">    return 内部函数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中</p><ul><li>内部函数 + 变量（内部函数能访问到这个变量） =  闭包</li><li>return  内部函数只是为了能使用到这个内部函数 ， 也就是能使用闭包</li><li>函数套函数是为了隐藏一个变量 或者说这就是闭包的作用</li></ul><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function create()</span><br><span class="line">&#123;</span><br><span class="line">  var n=999;</span><br><span class="line">  return &#123;</span><br><span class="line">    set : function(aaa)&#123;</span><br><span class="line">        n = aaa;</span><br><span class="line">    &#125;,</span><br><span class="line">    get : function()&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = create();</span><br><span class="line">var b = create();</span><br><span class="line">a.set(2);</span><br><span class="line">console.log(a.get());</span><br><span class="line">console.log(b.get());</span><br></pre></td></tr></table></figure><ul><li>闭包的作用就是间接的访问一个变量 ，隐藏一个变量</li><li>去掉那个外层函数  变量就会很容易被直接使用并且修改</li><li>n 是一个局部变量 ，在函数外面是使用不到这个变量的</li><li>这时候get 和 set  函数就是 用来间接访问这个变量的访问器</li><li>闭包和变量的作用域有关</li></ul><p>在我们写js代码的时候会很容易就出现闭包， 而不是我们经常有意的去创造闭包<br>引用维基百科：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h1&gt;&lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="闭包" scheme="https://hongtao-huang.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配</title>
    <link href="https://hongtao-huang.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <id>https://hongtao-huang.github.io/移动端适配/</id>
    <published>2018-05-26T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="meta-viewport"><a href="#meta-viewport" class="headerlink" title="meta viewport"></a>meta viewport</h2><p> <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</code><br>viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code><br>目前主流浏览器使用<br>initial-scale属性控制页面最初加载时的缩放等级。maximum-scale、minimum-scale及user-scalable属性控制允许用户以怎样的方式放大或缩小页面。</p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><ul><li>我的理解就是用来辨别屏幕大小从而来使用不同的css样式达到大小屏幕的自适应</li></ul><ul><li><p>例如 iphone5/5s 屏幕宽度为 320 iphone6/7/8 屏幕宽度为 375</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- link元素中的CSS媒体查询 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 320px)&quot; href=&quot;iphone5.css&quot; /&gt;</span><br><span class="line"> &lt;link rel=&quot;stylesheet&quot; media=&quot;(min-width: 321px) and (max-width: 375px)&quot; href=&quot;iphone678.css&quot; /&gt;</span><br></pre></td></tr></table></figure><p>以上例子就是当屏幕最大为320px时 使用iphone.css<br>以上例子就是当屏幕最小321px最大为375px时 使用iphone678.css  </p><p> 也可以在css中给某些元素设置  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 样式表中的CSS媒体查询 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 320px) &#123;</span><br><span class="line">.nav &#123;</span><br><span class="line">  display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li>而有些公司对于移动端的适配 都是后台开发人员根据屏幕的尺寸来使用 不同的html ， 如写代码啦  </li><li>还有比如淘宝的适配就是不同的设备访问的网站不同  比如电脑访问淘宝就是taobao.com  ,手机访问就是m.taobao.com</li></ul><h2 id="动态REM"><a href="#动态REM" class="headerlink" title="动态REM"></a>动态REM</h2><ul><li>为了在不同的手机页面显示的内容及布局都是一样的 ， 比如说 iphone5 宽度是320px<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frnge6bj39j30ah09d748.jpg" alt=""><br>iphone6 宽度是375px<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frngfzkmpkj30bn09ewef.jpg" alt=""><br>整体的显示效果是一样的，苹果6会显示的大一点。 网页会随着不同的手机而进行等比的放大与缩小，那么动态rem就是用来解决这个 问题的</li></ul><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><pre><code>常用的有  </code></pre><ul><li>px  就是像素点的意思</li><li>em  一个M的大小 ，或者不是很正确的一个汉字大小 ，相对于当前元素的font-size</li><li>vh  视口高度的1/100，其次，它不像rem那样被广泛支持。</li><li>vw  视口宽度的1/100，其次，它不像rem那样被广泛支持。</li><li>rem root em 根的em  ，一个文档的根是html  ，也就是1rem === html的font-size</li></ul><h3 id="计算rem"><a href="#计算rem" class="headerlink" title="计算rem"></a>计算rem</h3><ul><li><p>利用js获取页面宽度， 设置根元素的font-size  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var pageWidth = window.innerWidth;</span><br><span class="line">    document.write(&apos;&lt;style&gt;html&#123;font-size:&apos;+ pageWidth/10 +&apos;px;&#125;&lt;/style&gt;&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>这样的话 1rem 就相当与 页面宽度的 10% ， 就能知道具体设置的宽高是多少</p></li><li><p>但是rem 如果根据设计师的设计搞来写 ， 算rem 会很麻烦 ， 于是就用到了sass 的 px2rem 函数计算</p></li><li><p>windows安装sass 方法<br>i 安装ruby<br><a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">下载ruby</a>  下载最新版本<br>在命令行中输入<code>ruby -v</code>命令来确认是否安装成功：<br>ii 安装sass<br>Sass是Ruby语言写的，安装Sass必须先安装Ruby。假定你已经安装好了Ruby，接着在命令行输入下面的命令：<br><code>gem install sass</code> ，安装完成后，通过<code>sass -v</code>命令来判断是否安装成功</p><p>装好后 可以在scss 文件中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$rem: 640;    // 设计稿的宽度</span><br><span class="line">@function px2rem($px) &#123;</span><br><span class="line">  @return ($px / $rem) * 10 + rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">  width: px2rem(320px);  // 算出来的 width: 5rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动端适配&quot;&gt;&lt;a href=&quot;#移动端适配&quot; class=&quot;headerlink&quot; title=&quot;移动端适配&quot;&gt;&lt;/a&gt;移动端适配&lt;/h1&gt;&lt;h2 id=&quot;meta-viewport&quot;&gt;&lt;a href=&quot;#meta-viewport&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="meta-viewport media rem" scheme="https://hongtao-huang.github.io/tags/meta-viewport-media-rem/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="https://hongtao-huang.github.io/flex/"/>
    <id>https://hongtao-huang.github.io/flex/</id>
    <published>2018-05-23T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">阮一峰-Flex布局</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">阮一峰-Flex布局实例教程</a></p><h2 id="Flex布局-1"><a href="#Flex布局-1" class="headerlink" title="Flex布局"></a>Flex布局</h2><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</li></ul><h2 id="Flex布局属性"><a href="#Flex布局属性" class="headerlink" title="Flex布局属性"></a>Flex布局属性</h2><ul><li>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</li><li>主轴：水平线 </li><li>交叉轴：垂直线</li></ul><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><ul><li>决定主轴的方向 或  交叉轴的方向<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">   // flex-direction: row;  从左至右</span><br><span class="line">        // flex-direction: row-reverse;  从右至左</span><br><span class="line">        // flex-direction: column;  从上至下</span><br><span class="line">        // flex-direction: column-reverse;  从下至上</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><ul><li>决定如何换行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    //flex-wrap: nowrap;     不换行</span><br><span class="line">        //flex-wrap: wrap;    换行，第一行在上方（从上往下）</span><br><span class="line">        //flex-wrap: wrap-reverse;  换行，第一行在下方（从下往上）</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><ul><li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> // flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">    // flex-flow: row nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><ul><li>决定了项目的水平对齐方式</li><li>与 主轴的方向有关，以下假设为<code>flex-direction: row;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  // justify-content: flex-start;   左对齐</span><br><span class="line">  // justify-content: flex-end;    右对齐</span><br><span class="line">  // justify-content: center;     居中对齐</span><br><span class="line">  // justify-content: space-between;  两端对齐，项目之间的间隔都相等。</span><br><span class="line">  // justify-content: space-around; 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><ul><li>决定了项目的垂直对齐方式</li><li>与交叉轴的方向有关，以下假设为<code>flex-direction: column;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// align-items: flex-start 上对齐</span><br><span class="line">// align-items: flex-end：下对齐</span><br><span class="line">// align-items: center：居中对齐</span><br><span class="line">// align-items: baseline: 项目的第一行文字的基线对齐。</span><br><span class="line">// align-items: stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure></li></ul><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><ul><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line"> // align-content: flex-start;  与交叉轴的起点对齐。</span><br><span class="line"> // align-content: flex-end;    与交叉轴的终点对齐。</span><br><span class="line"> // align-content: center;与交叉轴的中点对齐。</span><br><span class="line"> // align-content: space-between;  与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line"> // align-content: space-around;  每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line"> // align-content: stretch;  轴线占满整个交叉轴。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">order : 0123...（优先级设置） 项目的排列顺序</span><br><span class="line">flex-grow：0123...（默认为0,不放大） 项目的放大比例，自动按比列分配容器空间</span><br><span class="line">flex-shrink：0123...（默认为1,默认空间不足时可等比缩放，为0不缩）</span><br><span class="line">flex-basis：length | auto 设置项目的主轴空间（main size） ，auto 为项目的本来大小</span><br><span class="line">flex： 前三个的省略写法属性 ，两个快捷值 auto（1  1 auto） none （0 0 auto）</span><br><span class="line">align-self：auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flex布局&quot;&gt;&lt;a href=&quot;#Flex布局&quot; class=&quot;headerlink&quot; title=&quot;Flex布局&quot;&gt;&lt;/a&gt;Flex布局&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-g
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="flex" scheme="https://hongtao-huang.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>文字溢出省略文本对齐垂直居中margin合并</title>
    <link href="https://hongtao-huang.github.io/%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E7%9C%81%E7%95%A5%E6%96%87%E6%9C%AC%E5%AF%B9%E9%BD%90%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>https://hongtao-huang.github.io/文字溢出省略文本对齐垂直居中/</id>
    <published>2018-05-19T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文字溢出省略文本对齐垂直居中margin合并"><a href="#文字溢出省略文本对齐垂直居中margin合并" class="headerlink" title="文字溢出省略文本对齐垂直居中margin合并"></a>文字溢出省略文本对齐垂直居中margin合并</h1><h2 id="文本超出溢出以及如何添加省略号"><a href="#文本超出溢出以及如何添加省略号" class="headerlink" title="文本超出溢出以及如何添加省略号"></a>文本超出溢出以及如何添加省略号</h2><h3 id="一行文本"><a href="#一行文本" class="headerlink" title="一行文本"></a>一行文本</h3><h4 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">     width:100px;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">      </span><br><span class="line">     /* white-space:nowrap; */   /*不换行，超出div宽度的文字溢出*/</span><br><span class="line">     /* overflow:hidden; */         /* 超出宽度部分自动隐藏 */</span><br><span class="line">     /* text-overflow:ellipsis; */   /*超出部分变成省略号*/</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii nihaoninnnn你好</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgfunzpr7j306h02jt8i.jpg" alt=""></p><ul><li>第一行没有换行是因为浏览器把它看成一个英文单词</li><li>所以从现象可以看出默认超出宽度是会换行的</li></ul><h4 id="不换行，超出div宽度的文字溢出"><a href="#不换行，超出div宽度的文字溢出" class="headerlink" title="不换行，超出div宽度的文字溢出"></a>不换行，超出div宽度的文字溢出</h4><p>恢复<code>white-space:nowrap;</code> 这个属性<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgfxlji7zj309s01djr6.jpg" alt=""></p><h4 id="超出部分隐藏，超出部分变省略号"><a href="#超出部分隐藏，超出部分变省略号" class="headerlink" title="超出部分隐藏，超出部分变省略号"></a>超出部分隐藏，超出部分变省略号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgg18sblhj305l01a0ru.jpg" alt=""></p><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">     width:100px;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">      </span><br><span class="line">     display: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: 3;   /*最多显示三行文本，超出就变省略号*/</span><br><span class="line">  -webkit-box-orient: vertical;  </span><br><span class="line">   overflow:hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii nihaoninnnn你好范德萨发热管杜莎夫人</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgg504w73j304r032glg.jpg" alt=""></p><h2 id="多行文本两端对齐"><a href="#多行文本两端对齐" class="headerlink" title="多行文本两端对齐"></a>多行文本两端对齐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    span&#123;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  width:4em;</span><br><span class="line">  text-align:justify;   /*文本换行对齐*/</span><br><span class="line">  font-size:20px;</span><br><span class="line">  line-height:20px;</span><br><span class="line">&#125;</span><br><span class="line">span::after&#123;</span><br><span class="line">  content:&apos;&apos;;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  width:100%;</span><br><span class="line">&#125;  </span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;span&gt;姓名&lt;/span&gt; &lt;br&gt;</span><br><span class="line">  &lt;span&gt;联系方式&lt;/span&gt; &lt;br&gt;</span><br><span class="line">  &lt;span&gt;炸弹人&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frggd20paij304x03dt8k.jpg" alt=""></p><h2 id="文字垂直居中"><a href="#文字垂直居中" class="headerlink" title="文字垂直居中"></a>文字垂直居中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">   div&#123;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">    line-height:30px;</span><br><span class="line">    padding:5px 0</span><br><span class="line">&#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">文字垂直居中</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frggggrzvkj307j02ojr6.jpg" alt=""></p><ul><li>遵循一条原则  能不用height 就别用 ，用padding撑起想要的高度</li></ul><h2 id="容器垂直居中"><a href="#容器垂直居中" class="headerlink" title="容器垂直居中"></a>容器垂直居中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    body&#123;</span><br><span class="line">      box-sizing:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    .dad&#123;</span><br><span class="line">      border: 2px solid blue;</span><br><span class="line">      height: 100vh;</span><br><span class="line">      display: flex;</span><br><span class="line">      justify-content: center;</span><br><span class="line">      align-items: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .son&#123;</span><br><span class="line">      border:3px solid red;</span><br><span class="line">      width: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;dad&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">      fdksfdlmks sdfefdsfdsfwef</span><br><span class="line">      fdfwdfsefrf</span><br><span class="line">      dfrefdreg</span><br><span class="line">      fefdsgrdsfs</span><br><span class="line">      fdefregr</span><br><span class="line">      dgersd</span><br><span class="line">      gre</span><br><span class="line">      dfwe</span><br><span class="line">      fd</span><br><span class="line">      fe</span><br><span class="line">      dfd</span><br><span class="line">      erfrgrgfdsrgf</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgpt4sz6gj30e80ozaai.jpg" alt=""></p><ul><li>新时代前端记住这种用flex 布局来垂直居中，就好了</li></ul><h2 id="margin合并"><a href="#margin合并" class="headerlink" title="margin合并"></a>margin合并</h2><h3 id="两个div之间的margin合并"><a href="#两个div之间的margin合并" class="headerlink" title="两个div之间的margin合并"></a>两个div之间的margin合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">      box-sizing:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">   .div1&#123;</span><br><span class="line">     border: 1px solid red;</span><br><span class="line">     height:100px;</span><br><span class="line">     margin:10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .div2&#123;</span><br><span class="line">      height:100px;</span><br><span class="line">      border:1px solid green;</span><br><span class="line">      margin:10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=div1&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=div2&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgmolf25bj30k30bbmxn.jpg" alt=""></p><ul><li>两个div 分别给了10px的margin</li><li>两个div之间的间距按照直觉应该是20px</li><li>通过开发者工具我们可以看到它们之间只有10px</li><li>这就说明他们的margin合并了</li></ul><h3 id="父子div的margin合并"><a href="#父子div的margin合并" class="headerlink" title="父子div的margin合并"></a>父子div的margin合并</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">      box-sizing:border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">    &#125;</span><br><span class="line">   .dad&#123;</span><br><span class="line">     outline: 1px solid red;</span><br><span class="line">     margin:10px 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .son&#123;</span><br><span class="line">      height:100px;</span><br><span class="line">      border:1px solid green;</span><br><span class="line">      margin:20px 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=dad&gt;</span><br><span class="line">    &lt;div class=son&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgmwwqo4ej30kt0btt98.jpg" alt=""></p><ul><li>父元素margin为10px 子元素margin为20px </li><li>正常的想法应该是子元素在父元素中离父元素边框有20px的间距，而父元素离body的边框有10px的间距</li><li>通过开发者工具我们可以看到子元素的margin超出了父元素边框并且离body间距是20px</li><li>这就说明子元素与父元素的margin合并了</li><li>注意这里父元素的边框线用的是outline</li></ul><h3 id="那么为什么呢？"><a href="#那么为什么呢？" class="headerlink" title="那么为什么呢？"></a>那么为什么呢？</h3><h4 id="将父元素的边框设置为border，或者给父元素加一padding"><a href="#将父元素的边框设置为border，或者给父元素加一padding" class="headerlink" title="将父元素的边框设置为border，或者给父元素加一padding"></a>将父元素的边框设置为border，或者给父元素加一padding</h4><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgn7hvoclj30ec05gmwy.jpg" alt=""></p><ul><li>就会发现神奇的好了</li></ul><h4 id="在两个div之间再加一个div-设置border或者padding"><a href="#在两个div之间再加一个div-设置border或者padding" class="headerlink" title="在两个div之间再加一个div 设置border或者padding"></a>在两个div之间再加一个div 设置border或者padding</h4><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1frgndw6rl6j30eq074dfn.jpg" alt=""></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>因此总结一下就是</li><li>两个元素的margin合并是因为中间没有阻挡它们的属性就会合并在一起</li><li>比如说border就是一堵墙，堵在两个margin之间就不会合并了</li><li>或者说margin碰到关于border/padding这种元素，就是距离这个元素的margin有多少</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文字溢出省略文本对齐垂直居中margin合并&quot;&gt;&lt;a href=&quot;#文字溢出省略文本对齐垂直居中margin合并&quot; class=&quot;headerlink&quot; title=&quot;文字溢出省略文本对齐垂直居中margin合并&quot;&gt;&lt;/a&gt;文字溢出省略文本对齐垂直居中margin
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="https://hongtao-huang.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Js插入排序</title>
    <link href="https://hongtao-huang.github.io/%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5-%E8%AE%A1%E6%95%B0-%E5%9F%BA%E6%95%B0/"/>
    <id>https://hongtao-huang.github.io/排序-插入-计数-基数/</id>
    <published>2018-05-04T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js插入排序"><a href="#Js插入排序" class="headerlink" title="Js插入排序"></a>Js插入排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序原理"><a href="#插入排序原理" class="headerlink" title="插入排序原理"></a>插入排序原理</h3><ul><li>用未参与排序的数与已经排好序的数从后往前做比较</li><li>比较中找到自己的位置然后插入到该位置<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqz4z2kuuyg30b00f5n4e.jpg" alt=""><h3 id="插入排序步骤"><a href="#插入排序步骤" class="headerlink" title="插入排序步骤"></a>插入排序步骤</h3></li><li>确定外层循环 index为已排好序的个数</li><li>内层循环从已排好序的最后位置开始往前比较</li><li>整个已排序部分搜索一遍保存最后的索引</li><li>插入 splice函数</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = [10,38,45,50,48,13,27,20];</span><br><span class="line">var index = 0;</span><br><span class="line">for(var i = 1; i &lt; a.length; i ++)&#123;</span><br><span class="line">  index = i;</span><br><span class="line">    for(var j = i - 1; j &gt;= 0; j--)&#123;</span><br><span class="line">        if(a[i] &lt; a[j] )&#123;</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a.splice(index,0,a[i]);  //插入a[i]</span><br><span class="line">    a.splice(i+1,1);  // 由于数组变了，所以原先a[i]的值到a[i+1]去了，删掉它</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Js插入排序&quot;&gt;&lt;a href=&quot;#Js插入排序&quot; class=&quot;headerlink&quot; title=&quot;Js插入排序&quot;&gt;&lt;/a&gt;Js插入排序&lt;/h1&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础排序" scheme="https://hongtao-huang.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Js冒泡排序&amp;选择排序</title>
    <link href="https://hongtao-huang.github.io/Js%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://hongtao-huang.github.io/Js冒泡排序选择排序/</id>
    <published>2018-05-03T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Js冒泡排序-amp-选择排序"><a href="#Js冒泡排序-amp-选择排序" class="headerlink" title="Js冒泡排序&amp;选择排序"></a>Js冒泡排序&amp;选择排序</h1><h2 id="冒泡排序原理"><a href="#冒泡排序原理" class="headerlink" title="冒泡排序原理"></a>冒泡排序原理</h2><ul><li>两相邻的数依次比较</li><li>若从小到大排列两两比较时前一个数比后一个数大互换位置</li><li>相互比较完一轮最大的数就会到最后面，并且不再参与比较</li><li>循环比较 直到比较完成<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqy8ra7e3cg30d706vn7w.jpg" alt=""></li></ul><h2 id="冒泡排序步骤"><a href="#冒泡排序步骤" class="headerlink" title="冒泡排序步骤"></a>冒泡排序步骤</h2><ol><li>确定外层循环次数   数组的长度</li><li>确定内层循环的次数  每确定冒泡一个数内层循环减少一次 数组长度 减 外层循环的index </li><li>相邻两数相比较  前一个数比后一个数大 互换两数位置</li></ol><h2 id="冒泡排序代码实现"><a href="#冒泡排序代码实现" class="headerlink" title="冒泡排序代码实现"></a>冒泡排序代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var a = [36,26,27,2,4,19,50,48];</span><br><span class="line">var temp;</span><br><span class="line"></span><br><span class="line">for(var i= 0; i &lt;  a.length; i++)</span><br><span class="line">for(var j = 0; j &lt; a.length-i; j++)&#123;</span><br><span class="line">    if(a[j] &gt;  a[j+1])&#123;</span><br><span class="line">        temp = a[j];</span><br><span class="line">        a[j] = a[j+1];</span><br><span class="line">        a[j+1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><h2 id="选择排序原理"><a href="#选择排序原理" class="headerlink" title="选择排序原理"></a>选择排序原理</h2><ul><li>找未排序的元素中最小的数</li><li>将最小数与起始位置互换</li><li>直到排序完成<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqy96u2mbgg30gg06n7aa.jpg" alt=""></li></ul><h2 id="选择排序步骤"><a href="#选择排序步骤" class="headerlink" title="选择排序步骤"></a>选择排序步骤</h2><ol><li>确定外层循环次数 index为每一次寻找最小值的起始位置 直到数组长度</li><li>内层循环每次都是由起始位置 +1 直到数组长度</li><li>假设每一次的起始位置为最小数 碰到更小的用更小的和后面的数继续做比较</li><li>保存最小数的索引</li><li>内层循环结束后最小数与起始位置互换</li></ol><h2 id="选择排序代码实现"><a href="#选择排序代码实现" class="headerlink" title="选择排序代码实现"></a>选择排序代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = [4,12,13,4,3,42,33,4,43,44];</span><br><span class="line">var temp;</span><br><span class="line">var minIndex;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; a.length; i ++)&#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    for(var j = i + 1; j &lt; a.length; j++)&#123;</span><br><span class="line">        if(a[minIndex] &gt; a[j])&#123;</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = a[minIndex];</span><br><span class="line">    a[minIndex] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Js冒泡排序-amp-选择排序&quot;&gt;&lt;a href=&quot;#Js冒泡排序-amp-选择排序&quot; class=&quot;headerlink&quot; title=&quot;Js冒泡排序&amp;amp;选择排序&quot;&gt;&lt;/a&gt;Js冒泡排序&amp;amp;选择排序&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序原理&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="基础排序冒泡法" scheme="https://hongtao-huang.github.io/tags/%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E5%86%92%E6%B3%A1%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>css的position值</title>
    <link href="https://hongtao-huang.github.io/css%E7%9A%84position%E5%80%BC/"/>
    <id>https://hongtao-huang.github.io/css的position值/</id>
    <published>2018-04-27T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css的position值"><a href="#css的position值" class="headerlink" title="css的position值"></a>css的position值</h1><p>CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。</p><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><ul><li>正常的文档流会根据元素的类型来流动</li><li>内联元素会从左至右流动，显示不下去之后会换行继续从左向右</li><li>块级元素从上往下流动</li><li>脱离文档流的方法有浮动，绝对定位，固定定位</li></ul><h2 id="position5个取值"><a href="#position5个取值" class="headerlink" title="position5个取值"></a>position5个取值</h2><h3 id="static-相对定位"><a href="#static-相对定位" class="headerlink" title="static  相对定位"></a>static  相对定位</h3><blockquote><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p></blockquote><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><blockquote><p>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。<br>相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。相对定位的元素并未脱离文档流</p></blockquote><h3 id="absolute-绝对定位"><a href="#absolute-绝对定位" class="headerlink" title="absolute  绝对定位"></a>absolute  绝对定位</h3><blockquote><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。<br>绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）,视窗。绝对定位的元素脱离了文档流</p></blockquote><h3 id="fixed-固定定位"><a href="#fixed-固定定位" class="headerlink" title="fixed 固定定位"></a>fixed 固定定位</h3><blockquote><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform  属性非 none 时，容器由视口改为该祖先。<br>固定定位会固定显示在设置的位置，脱离了文档流</p></blockquote><h3 id="sticky-粘性定位"><a href="#sticky-粘性定位" class="headerlink" title="sticky 粘性定位"></a>sticky 粘性定位</h3><blockquote><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。<br>粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。例如：</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;css的position值&quot;&gt;&lt;a href=&quot;#css的position值&quot; class=&quot;headerlink&quot; title=&quot;css的position值&quot;&gt;&lt;/a&gt;css的position值&lt;/h1&gt;&lt;p&gt;CSS position属性用于指定一个元素在文档中
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="position" scheme="https://hongtao-huang.github.io/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>CSS-元素宽高是由什么决定的</title>
    <link href="https://hongtao-huang.github.io/css%E5%AE%BD%E9%AB%98%E7%9A%84%E5%86%B3%E5%AE%9A/"/>
    <id>https://hongtao-huang.github.io/css宽高的决定/</id>
    <published>2018-04-13T12:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-元素宽高是由什么决定的"><a href="#CSS-元素宽高是由什么决定的" class="headerlink" title="CSS-元素宽高是由什么决定的"></a>CSS-元素宽高是由什么决定的</h1><blockquote><p> 任何元素都可以是块级元素 或 行内元素<br> 因为每个元素都可以设置成行内元素或块级元素   </p></blockquote><h2 id="行内元素表现形式"><a href="#行内元素表现形式" class="headerlink" title="行内元素表现形式"></a>行内元素表现形式</h2><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb3v2gjhvj309e01eq2q.jpg" alt=""><br>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br><span class="line">&lt;span&gt;hello! &lt;/span&gt;</span><br></pre></td></tr></table></figure></p><ul><li>行内元素就是在一行中显示，如果后面跟着的还是行内元素，就继续跟在后面显示，当一行不够显示时自动换行</li></ul><h2 id="块级元素表现形式"><a href="#块级元素表现形式" class="headerlink" title="块级元素表现形式"></a>块级元素表现形式</h2><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb423gjnaj309u02igld.jpg" alt=""><br>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;border: 1px solid red;&quot;&gt;123&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;border: 1px solid red;&quot;&gt;123&lt;/div&gt;</span><br><span class="line">  &lt;div style=&quot;border: 1px solid red;&quot;&gt;123&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><ul><li>块级元素不管后面跟着的是什么元素，都会另起一行。也就是说块级元素会独占一行。<h2 id="元素的高度由什么决定的"><a href="#元素的高度由什么决定的" class="headerlink" title="元素的高度由什么决定的"></a>元素的高度由什么决定的</h2><h3 id="span-行内元素高度由什么决定的"><a href="#span-行内元素高度由什么决定的" class="headerlink" title="span 行内元素高度由什么决定的"></a>span 行内元素高度由什么决定的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">    &#125;</span><br><span class="line">    span&#123;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">      font-size: 72px;</span><br><span class="line">    &#125;</span><br><span class="line">    .s1&#123;</span><br><span class="line">       font-family: sans-serif;  </span><br><span class="line">    &#125;</span><br><span class="line">    .s2&#123;</span><br><span class="line">       font-family: monospace;</span><br><span class="line">    &#125;</span><br><span class="line">    .s3&#123;</span><br><span class="line">      font-family:serif ;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;span class=&quot;s1&quot;&gt;ABC&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;s2&quot;&gt;ABC&lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;s3&quot;&gt;ABC&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb4g6bbdmj30fr02yt8r.jpg" alt=""></p><ul><li>可以看到， 我给每个span 都设置了一个字体， 而中间字体的高度明显高于两边的字体 。</li><li>每一种字体的设计师不一样， 每一种字体的设计师都会对自己设置出来的字体的默认行高不一样</li><li>所以，行内元素内容为字的元素的行高是由 字体的默认行高决定的。  </li><li>比较详细的解说可以看看这篇知乎文章<a href="https://zhuanlan.zhihu.com/p/27381252" target="_blank" rel="noopener">字号与行高</a></li></ul><h3 id="div-块级元素高度由什么决定的"><a href="#div-块级元素高度由什么决定的" class="headerlink" title="div 块级元素高度由什么决定的"></a>div 块级元素高度由什么决定的</h3><ul><li>从上面的程序代码可以看到， span是由一个div包裹的 。 div的告诉是中间最高的span的高度。</li><li>也就是说块级元素的高度是由它的内容决定的，而且是所有内容中最高的内容决定的。</li></ul><h2 id="元素的宽度是由什么决定的"><a href="#元素的宽度是由什么决定的" class="headerlink" title="元素的宽度是由什么决定的"></a>元素的宽度是由什么决定的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">      font-size: 72px;</span><br><span class="line">    &#125;</span><br><span class="line">    span&#123;</span><br><span class="line">      border: 1px solid red;</span><br><span class="line">      font-size: 72px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;span&gt;12345678&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;12345678&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb50ogjyyj30g805jwep.jpg" alt=""></p><ul><li>行内元素的宽度是由它的内容决定的，行内元素不能设置宽高</li><li><p>块级元素当没有设置宽度是默认100%宽 ，所以才会到最右边。当设置了宽度是就是固定的宽度 ， 下面我们把宽度设置为200px；<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb5600a8aj30fc04q3yp.jpg" alt=""></p></li><li><p>看div的蓝色边框 ， 宽度就是固定的200px;</p></li><li><p>如果把div设置成行内元素，  它的宽度是怎样的呢,设置属性display:inline<br><img src="https://ws1.sinaimg.cn/large/006WOZytgy1fqb5itt1v9j30fu04vdg0.jpg" alt=""></p></li><li><p>div的宽度会收缩</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-元素宽高是由什么决定的&quot;&gt;&lt;a href=&quot;#CSS-元素宽高是由什么决定的&quot; class=&quot;headerlink&quot; title=&quot;CSS-元素宽高是由什么决定的&quot;&gt;&lt;/a&gt;CSS-元素宽高是由什么决定的&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 任何元素
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="行内元素  块级元素  span div" scheme="https://hongtao-huang.github.io/tags/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-span-div/"/>
    
  </entry>
  
  <entry>
    <title>CSS</title>
    <link href="https://hongtao-huang.github.io/css-Learn1/"/>
    <id>https://hongtao-huang.github.io/css-Learn1/</id>
    <published>2018-04-10T03:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="引入css的4种方法"><a href="#引入css的4种方法" class="headerlink" title="引入css的4种方法"></a>引入css的4种方法</h2><ol><li>style 属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height:100px;background-color: red;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><div style="height:100px;background-color: red;"></div><ol><li>style 标签<br>在head标签内容中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line"> div&#123;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><div style="height:100px;background-color: red;"></div><ol><li><p>link 标签引入<br>i 创建一个a.css文件 ，并添加内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line"> height: 100px;</span><br><span class="line"> background-color: red;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> ii 在head中添加 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;a.css&quot;&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li>import<br> 该方法是在一个css文件中引入另一个css文件，语法为 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import url(&quot;b.css&quot;)</span><br></pre></td></tr></table></figure></li></ol><pre><code>（以下观点属个人理解）</code></pre><h2 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h2><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    a&#123;</span><br><span class="line">      text-decoration:none;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&#123;</span><br><span class="line">      list-style-type: none;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&gt;li&#123;</span><br><span class="line">      float:left;</span><br><span class="line">      margin:20px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HOME&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;ABOUT&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;CONTACT&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/04/09/5acb3337aa951.png" alt="导航栏.png"></p><p>在导航条下面加一个div<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">      width: 100px;</span><br><span class="line">      height: 100px;</span><br><span class="line">      background-color: grey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="未清除浮动效果"><a href="#未清除浮动效果" class="headerlink" title="未清除浮动效果"></a>未清除浮动效果</h3><p><img src="https://i.loli.net/2018/04/10/5acc1bb8afc89.png" alt="未清楚浮动.png"></p><h3 id="清楚浮动效果"><a href="#清楚浮动效果" class="headerlink" title="清楚浮动效果"></a>清楚浮动效果</h3><p><img src="https://i.loli.net/2018/04/10/5acc207970cc2.png" alt="2018-04-10 10-24-12 的屏幕截图.png"></p><ul><li>所以在给元素添加float后都有可能带来一些问题 ，所以我们需要清除浮动带来的影响。</li><li>清除浮动的办法有很多种，我们只用以下一种方法<br>i 给浮动元素的父元素的类  加  <code>clearfix</code><br>ii <code>clearfix</code> 的css代码具体实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after&#123;</span><br><span class="line">     content:&apos;&apos;;</span><br><span class="line">     display:block;</span><br><span class="line">     clear:both;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p> 整个网页就是在做一个垂直布局 ， 而水平布局就是在整体的纵向垂直布局上做一块内容的横向水平布局</p><h3 id="各块的垂直布局"><a href="#各块的垂直布局" class="headerlink" title="各块的垂直布局"></a>各块的垂直布局</h3><p><img src="https://i.loli.net/2018/04/10/5acc25c1a9055.png" alt="2018-04-10 10-45-56 的屏幕截图.png"></p><ul><li>可以看到导航栏部分和所有div做整体的垂直布局</li><li>而导航栏这一块里面又做了水平布局</li><li>所以  我觉得浏览器的布局就是整体在做垂直布局，但是又有水平布局组合的复杂布局</li></ul><h2 id="实用且好用的工具推荐"><a href="#实用且好用的工具推荐" class="headerlink" title="实用且好用的工具推荐"></a>实用且好用的工具推荐</h2><p><a href="https://c.m.163.com/news/a/DDJFF6P905118DFD.html?spss=newsapp&amp;fromhistory=1" target="_blank" rel="noopener">工具推荐</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;&lt;h2 id=&quot;引入css的4种方法&quot;&gt;&lt;a href=&quot;#引入css的4种方法&quot; class=&quot;headerlink&quot; title=&quot;引
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css布局 清除浮动 引入css的方法  推荐工具" scheme="https://hongtao-huang.github.io/tags/css%E5%B8%83%E5%B1%80-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8-%E5%BC%95%E5%85%A5css%E7%9A%84%E6%96%B9%E6%B3%95-%E6%8E%A8%E8%8D%90%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>定时切换全屏多窗口（linux-QT5）</title>
    <link href="https://hongtao-huang.github.io/%E5%AE%9A%E6%97%B6%E5%88%87%E6%8D%A2%E7%AA%97%E5%8F%A3/"/>
    <id>https://hongtao-huang.github.io/定时切换窗口/</id>
    <published>2018-03-26T12:10:00.000Z</published>
    <updated>2018-09-29T13:59:08.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时切换全屏多窗口（linux-QT5）"><a href="#定时切换全屏多窗口（linux-QT5）" class="headerlink" title="定时切换全屏多窗口（linux-QT5）"></a>定时切换全屏多窗口（linux-QT5）</h1><h2 id="新建多窗口"><a href="#新建多窗口" class="headerlink" title="新建多窗口"></a>新建多窗口</h2><ol><li>新建一个主工程 ，类名为Widget ， 基类为QWidget （主窗口）</li><li>添加新文件， 选择QT ，选择QT设计师界面类，  选择Dialog whitout Buttons （如此随便新建几个，这里我新建了两个  这里是对话窗口 或者  子窗口）</li></ol><h2 id="窗口全屏"><a href="#窗口全屏" class="headerlink" title="窗口全屏"></a>窗口全屏</h2><ol><li>widget 主窗口只需要使用 <code>showFullScreen()</code> 函数</li><li>dialog 对话窗口需要使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dialog2.setWindowFlags(Qt::Window);</span><br><span class="line">dialog2.showFullScreen();</span><br></pre></td></tr></table></figure></li></ol><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dialog2.setWindowFlags(Qt::Dialog);</span><br><span class="line">dialog2.showFullScreen();</span><br></pre></td></tr></table></figure></p><p>这两种方法是将窗口类型升为顶级（主）窗口模式，然后调用<code>dialog2.showFullScreen();</code>函数将子函数全屏显示。</p><ol><li>感兴趣的可以看一下 <a href="https://www.bbsmax.com/A/RnJWY1wYdq/" target="_blank" rel="noopener">关于窗口全屏显示</a></li></ol><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>这里是看的QT 快速入门系列教程第十篇：<br><a href="https://wizardforcel.gitbooks.io/qt-beginning/content/13.html" target="_blank" rel="noopener">QT定时器的两种方式</a></p><h2 id="关于关闭窗口相关函数"><a href="#关于关闭窗口相关函数" class="headerlink" title="关于关闭窗口相关函数"></a>关于关闭窗口相关函数</h2><p><a href="http://blog.csdn.net/xqhrs232/article/details/78211614" target="_blank" rel="noopener">关闭应用程序和窗口的函数</a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="widget-h文件中"><a href="#widget-h文件中" class="headerlink" title="widget.h文件中"></a><code>widget.h</code>文件中</h3><ol><li><p>调用头文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;dialog1.h&quot;</span><br><span class="line">#include &quot;dialog2.h&quot;   //子窗口文件名字的头文件</span><br></pre></td></tr></table></figure></li><li><p><code>private slots:</code> 下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dialog1Show();</span><br><span class="line">void dialog2Show();</span><br></pre></td></tr></table></figure></li><li><p><code>private:</code> 下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dialog1 dialog1;</span><br><span class="line">Dialog2 dialog2;</span><br><span class="line">int id1 , num=0; //id1 为定时器溢出变量 ，num 为切换窗口变量</span><br></pre></td></tr></table></figure></li><li><p>添加定时器事件函数声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected:</span><br><span class="line">void timerEvent(QTimerEvent *);</span><br></pre></td></tr></table></figure></li></ol><h3 id="widget-cpp文件中"><a href="#widget-cpp文件中" class="headerlink" title="widget.cpp文件中"></a><code>widget.cpp</code>文件中</h3><ol><li><p>构造函数中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">showFullScreen(); // 为了运行时就可以全屏</span><br><span class="line">id1 = startTimer(5000);  // 开启一个5秒定时器，返回其ID</span><br></pre></td></tr></table></figure></li><li><p>定义定时器事件处理函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Widget::timerEvent(QTimerEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">   if (event-&gt;timerId() == id1) &#123;       // 判断是哪个定时器</span><br><span class="line">       if(num == 0)&#123;        // num=0 的时候调用第一个子窗口显示</span><br><span class="line">            dialog1Show();</span><br><span class="line">       &#125;</span><br><span class="line">       else if(num == 1)&#123;   // num=1 的时候调用第二个子窗口显示</span><br><span class="line">           dialog2Show();</span><br><span class="line">       &#125;</span><br><span class="line">       else if(num == 2)&#123;    //num=2 的时候关闭第二个窗口显示，设置主窗口为全屏显示，然后显示主窗口</span><br><span class="line">           dialog2.close();</span><br><span class="line">           showFullScreen();</span><br><span class="line">           this-&gt;show();</span><br><span class="line">       &#125;</span><br><span class="line">       num++;</span><br><span class="line">       num %= 3;       // 5秒进来一次  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义第一个子窗口显示函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Widget::dialog1Show()&#123;</span><br><span class="line"></span><br><span class="line">    this-&gt;hide();</span><br><span class="line">    dialog1.setWindowFlags(Qt::Dialog);</span><br><span class="line">//    dialog1.setWindowFlags(Qt::Window);</span><br><span class="line">    dialog1.showFullScreen();</span><br><span class="line">    dialog1.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义第二个子窗口显示函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Widget::dialog2Show()&#123;</span><br><span class="line">    dialog1.close();</span><br><span class="line">    dialog2.setWindowFlags(Qt::Dialog);</span><br><span class="line">//    dialog2.setWindowFlags(Qt::Window);</span><br><span class="line">    dialog2.showFullScreen();</span><br><span class="line">    dialog2.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>至此整个全屏定时切换窗口程序就完成了</li></ul><h2 id="简化，合并函数"><a href="#简化，合并函数" class="headerlink" title="简化，合并函数"></a>简化，合并函数</h2><ul><li>这里是把最后这部分显示函数合并为一个函数</li></ul><h3 id="widget-h-中修改"><a href="#widget-h-中修改" class="headerlink" title="widget.h 中修改"></a>widget.h 中修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private slots:</span><br><span class="line">void dialogShow(char cnt);</span><br></pre></td></tr></table></figure><h3 id="widget-cpp中修改"><a href="#widget-cpp中修改" class="headerlink" title="widget.cpp中修改"></a>widget.cpp中修改</h3><ol><li><p>定义 定时器事件处理函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Widget::timerEvent(QTimerEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">   if (event-&gt;timerId() == id1) &#123;       // 判断是哪个定时器</span><br><span class="line">       dialogShow(num);</span><br><span class="line">       num++;</span><br><span class="line">       num %= 3;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义显示函数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Widget::dialogShow(char cnt)&#123;</span><br><span class="line">    if(cnt == 0)&#123;</span><br><span class="line">        this-&gt;hide();</span><br><span class="line">        dialog1.setWindowFlags(Qt::Dialog);</span><br><span class="line">    //    dialog1.setWindowFlags(Qt::Window);</span><br><span class="line">        dialog1.showFullScreen();</span><br><span class="line">        dialog1.show();</span><br><span class="line">    &#125;else if(cnt == 1)&#123;</span><br><span class="line">        dialog1.close();</span><br><span class="line">        dialog2.setWindowFlags(Qt::Dialog);</span><br><span class="line">    //    dialog2.setWindowFlags(Qt::Window);</span><br><span class="line">        dialog2.showFullScreen();</span><br><span class="line">        dialog2.show();</span><br><span class="line">    &#125;else if (cnt == 2) &#123;</span><br><span class="line">        dialog2.close();</span><br><span class="line">        showFullScreen();</span><br><span class="line">        this-&gt;show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定时切换全屏多窗口（linux-QT5）&quot;&gt;&lt;a href=&quot;#定时切换全屏多窗口（linux-QT5）&quot; class=&quot;headerlink&quot; title=&quot;定时切换全屏多窗口（linux-QT5）&quot;&gt;&lt;/a&gt;定时切换全屏多窗口（linux-QT5）&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Embedded" scheme="https://hongtao-huang.github.io/categories/Embedded/"/>
    
    
      <category term="定时方式 切换多窗口" scheme="https://hongtao-huang.github.io/tags/%E5%AE%9A%E6%97%B6%E6%96%B9%E5%BC%8F-%E5%88%87%E6%8D%A2%E5%A4%9A%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>linux-QT5-6410-串口</title>
    <link href="https://hongtao-huang.github.io/6410%E4%B8%B2%E5%8F%A3/"/>
    <id>https://hongtao-huang.github.io/6410串口/</id>
    <published>2018-03-19T12:03:50.000Z</published>
    <updated>2018-09-30T01:46:47.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-QT5-6410-串口"><a href="#linux-QT5-6410-串口" class="headerlink" title="linux-QT5-6410-串口"></a>linux-QT5-6410-串口</h1><p>在Linux下我们只能使用查询Polling方式。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ul><li>新建项目 ，创建dialog，QT桌面项目</li></ul><h2 id="pro文件中添加："><a href="#pro文件中添加：" class="headerlink" title="pro文件中添加："></a>pro文件中添加：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT       += serialport</span><br></pre></td></tr></table></figure><h2 id="dialoh-h中添加"><a href="#dialoh-h中添加" class="headerlink" title="dialoh.h中添加"></a>dialoh.h中添加</h2><h3 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QtSerialPort/QSerialPort&gt;</span><br><span class="line">#include &lt;QtSerialPort/QSerialPortInfo&gt;   </span><br><span class="line">//以上两个头文件在QT5以下版本需要使用第三方文件，如 qextserialbase.cpp和qextserialbase.h 以及posix_qextserialport.cpp和posix_qextserialport.h</span><br><span class="line">#include &lt;QTimer&gt;</span><br></pre></td></tr></table></figure><h3 id="private下添加"><a href="#private下添加" class="headerlink" title="private下添加"></a>private下添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSerialPort *myCom;</span><br><span class="line">QTimer *readTimer;</span><br></pre></td></tr></table></figure><h3 id="添加私有槽函数"><a href="#添加私有槽函数" class="headerlink" title="添加私有槽函数"></a>添加私有槽函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private slots:</span><br><span class="line">void on_pushButton_clicked(); //”发送数据”按钮槽函数</span><br><span class="line">void readMyCom(); //读取串口</span><br></pre></td></tr></table></figure><h2 id="dialog-cpp中添加"><a href="#dialog-cpp中添加" class="headerlink" title="dialog.cpp中添加"></a>dialog.cpp中添加</h2><h3 id="构造函数下添加"><a href="#构造函数下添加" class="headerlink" title="构造函数下添加"></a>构造函数下添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">myCom = new QSerialPort();  </span><br><span class="line">myCom-&gt;setPortName(&quot;/dev/ttyS0&quot;);  </span><br><span class="line">myCom-&gt;open(QIODevice::ReadWrite);  </span><br><span class="line">myCom-&gt;setBaudRate(QSerialPort::Baud115200);  </span><br><span class="line">myCom-&gt;setBaudRate(QSerialPort::Data8);  </span><br><span class="line">myCom-&gt;setParity(QSerialPort::NoParity);  </span><br><span class="line">myCom-&gt;setStopBits(QSerialPort::OneStop);   </span><br><span class="line">myCom-&gt;setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">readTimer = new QTimer(this);</span><br><span class="line">readTimer-&gt;start(100);</span><br><span class="line">connect(readTimer,SIGNAL(timeout()),this,SLOT(readMyCom()));</span><br></pre></td></tr></table></figure><h3 id="构造函数外添加两个私有槽函数的实体"><a href="#构造函数外添加两个私有槽函数的实体" class="headerlink" title="构造函数外添加两个私有槽函数的实体"></a>构造函数外添加两个私有槽函数的实体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Widget::readMyCom() //读取串口数据并显示出来</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray temp = myCom-&gt;readAll(); //读取串口缓冲区的所有数据给临时变量temp</span><br><span class="line">   ui-&gt;textBrowser-&gt;insertPlainText(temp); //将串口的数据显示在窗口的文本浏览器中</span><br><span class="line">&#125;</span><br><span class="line">void Widget::on_pushButton_clicked() //发送数据</span><br><span class="line">&#123;</span><br><span class="line">    myCom-&gt;write(ui-&gt;lineEdit-&gt;text().toAscii()); //以ASCII码形式将数据写入串口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改UI界面"><a href="#修改UI界面" class="headerlink" title="修改UI界面"></a>修改UI界面</h2><ul><li>加入一个textBrowser的文本框</li><li>加入一个 lineEdit的输入框</li><li>加入一个pushbutoon的发送按钮</li></ul><blockquote><p>到这里一个基本的串口工程就建立完成了！！！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux-QT5-6410-串口&quot;&gt;&lt;a href=&quot;#linux-QT5-6410-串口&quot; class=&quot;headerlink&quot; title=&quot;linux-QT5-6410-串口&quot;&gt;&lt;/a&gt;linux-QT5-6410-串口&lt;/h1&gt;&lt;p&gt;在Linux下我们只
      
    
    </summary>
    
      <category term="Embedded" scheme="https://hongtao-huang.github.io/categories/Embedded/"/>
    
    
      <category term="串口" scheme="https://hongtao-huang.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>HTML语义化</title>
    <link href="https://hongtao-huang.github.io/html-%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
    <id>https://hongtao-huang.github.io/html-语义化/</id>
    <published>2018-03-18T07:20:00.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML-语义化-iframe-a-form的使用"><a href="#HTML-语义化-iframe-a-form的使用" class="headerlink" title="HTML-语义化-(iframe-a-form的使用)"></a>HTML-语义化-(iframe-a-form的使用)</h1><h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>参考资料：<br><a href="http://justineo.github.io/slideshows/semantic-html/" target="_blank" rel="noopener">semantic-html</a><br><a href="http://www.oschina.net/translate/about-html-semantics-front-end-architecture" target="_blank" rel="noopener">关于语义化 HTML 以及前端架构的一点思考</a><br><a href="http://www.zhihu.com/question/20455165" target="_blank" rel="noopener">如何理解 web 语义化</a></p><blockquote><p>语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></blockquote><p>列举几个常见的标签：<br>标题从大到小： h1 , h2 , h3 , h4 , h5 , h6<br>超链接： a<br>段落： p<br>无序列表： ul&gt;li<br>有序列表： ol&gt;li<br>自定义列表： dl&gt;{dt , dd}<br><a href="http://www.runoob.com/tags/tag-header.html" target="_blank" rel="noopener"><code>&lt;header&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/main" target="_blank" rel="noopener"><code>&lt;main&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section" target="_blank" rel="noopener"><code>&lt;section&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/footer" target="_blank" rel="noopener"><code>&lt;footer&gt;</code></a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article" target="_blank" rel="noopener"><code>&lt;article&gt;</code></a></p><h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>跳转页面。 发起 HTTP GET 请求</p><h3 id="target-属性"><a href="#target-属性" class="headerlink" title="target 属性"></a>target 属性</h3><ul><li>_blank 在新页面打开网页</li><li>_self 在当前页面打开网页  </li><li>_parent 在父页面打开网页  ， 这种要在当前页面被嵌套在一个iframe网页中容易体现出来</li><li>_top 在最外围页面打开网页 ， 这种要在当前页面被嵌套在多个iframe网页中容易体现出来</li></ul><h3 id="download"><a href="#download" class="headerlink" title="download"></a>download</h3><ul><li>表示下载href所对应的网页</li></ul><h2 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h2><p>默认宽高为300 * 150大小</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>可以在一个网页嵌套一个网页<br>例如：<br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpg8heal7qj309508sdfv.jpg" alt=""></li></ul><h3 id="与-a标签"><a href="#与-a标签" class="headerlink" title="与 a标签"></a>与 a标签</h3><p>看图：<br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpgqn7mfjuj309i084gm1.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe name=xxx src=&quot;http://baidu.com&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">    &lt;a href=&quot;http://qq.com&quot; target=&quot;xxx&quot;&gt;QQ&lt;/a&gt;</span><br><span class="line">    &lt;p&gt;我是iframe外面的P标签&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>QQ为 a 标签链接  ，它的target 属性等于 <code>xxx</code>,点击QQ 就会在iframe 中打开<code>qq.com</code>的网页<br>iframe 标签中本来打开的网页时<code>baidu.com</code> ，iframe 有一个属性时<code>name</code> ，<code>name</code>属性等于 a标签的target属性的值，所以点击a标签的时候就会在iframe中打开a标签中的URL。</p><h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><p>跳转页面。 发起 HTTP POST 请求<br>常用属性</p><ul><li>action ：  规定当提交表单时向何处发送表单数据。值为：URL</li><li>method ：  规定用于发送表单数据的 HTTP 方法。值只能是： GET 或 POST请求</li><li>target ：  规定在何处打开 action URL。值为：<br>i. _blank<br>ii. _self<br>iii. _parent<br>iv. _top<br>和 标签是一样的。  </li><li><code>&lt;form&gt;</code> 元素包含一个或多个如下的表单元素：   <code>&lt;input&gt;&lt;textarea&gt;&lt;button&gt;&lt;select&gt;&lt;option&gt;&lt;optgroup&gt;&lt;fieldset&gt;&lt;label&gt;</code>  </li></ul><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>type属性:</p><ol><li>text： 简单文本输入</li><li>password： 加密文本输入</li><li>radio： 单选框 ，相同的name ，为一组单选框</li><li>chekbox： 复选框 ， 相同的name ，为一组复选框</li><li>reset： 重置按钮 ，value为按钮名字，重置之前所有的输入</li><li>submit：提交按钮 ，value为按钮名字 ，将输入的内容提交至 form 标签的 action属性对应的URL中</li><li>button： 普通按钮 ，value为按钮名字<ul><li>注意： 要想输入的内容能提交 ， 需要加一个name属性</li></ul></li></ol><p>require属性： 加了这个属性就表示，输入框中必须有输入</p><p>lable : lable for id , lable标签for 中值  ，对应lable想关联的标签的id 值。</p><p>textarea: 文本输入框</p><p>select ： 下拉菜单 ， option为选项</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML-语义化-iframe-a-form的使用&quot;&gt;&lt;a href=&quot;#HTML-语义化-iframe-a-form的使用&quot; class=&quot;headerlink&quot; title=&quot;HTML-语义化-(iframe-a-form的使用)&quot;&gt;&lt;/a&gt;HTML-语义化-
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="W3C MDN HTML Tag 空Tag 可替换Tag" scheme="https://hongtao-huang.github.io/tags/W3C-MDN-HTML-Tag-%E7%A9%BATag-%E5%8F%AF%E6%9B%BF%E6%8D%A2Tag/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu17.10 友善6410 PC端QT开发环境搭建</title>
    <link href="https://hongtao-huang.github.io/Ubuntu17%E5%AE%89%E8%A3%85/"/>
    <id>https://hongtao-huang.github.io/Ubuntu17安装/</id>
    <published>2018-03-17T10:10:00.000Z</published>
    <updated>2018-09-29T13:59:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu17-10-友善6410-PC端QT开发环境搭建"><a href="#Ubuntu17-10-友善6410-PC端QT开发环境搭建" class="headerlink" title="Ubuntu17.10 友善6410 PC端QT开发环境搭建"></a>Ubuntu17.10 友善6410 PC端QT开发环境搭建</h1><h2 id="下载QT"><a href="#下载QT" class="headerlink" title="下载QT"></a>下载QT</h2><p><a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">QT各版本官方下载大全</a><br>这里我们下载最新的安装文件<br><code>qt-opensource-linux-x64-5.10.1.run</code><br>这个.run文件既包含了SDK也包含了IDE：QtCreator</p><h2 id="安装交叉编译工具"><a href="#安装交叉编译工具" class="headerlink" title="安装交叉编译工具"></a>安装交叉编译工具</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>将光盘 Linux 目录中的 arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz 复制到 Ubuntu某个<br>目录下如 tmp/（没有的话可以在自己的用户目录上创建）,然后进入到该目录,执行解压命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">tar xvzf arm-linux-gcc-4.5.1-v6-vfp-20120301.tgz –C /</span><br></pre></td></tr></table></figure></p><ul><li>注意:C 后面有个空格,并且 C 是大写的,它是英文单词“Change”的第一个字母,在此是改变目录的意思。</li><li>执行该命令,将把 arm-linux- gcc 安装到/opt/FriendlyARM/toolschain/4.5.1 目录。</li></ul><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p><code>#vim /root/.bashrc</code><br>编 辑 <code>/root/.bashrc</code> 文 件 , 注 意 “ bashrc ” 前 面 有 一 个 “ . ”, 修 改 最 后 一 行 为<br><code>export PATH=$PATH:/opt/FriendlyARM/toolschain/4.5.1/bin</code>,注意路径一定要写对,否则将不会有效。<br>重启 ，其实注销就行 。你随意<br>在命令行 输入<br><code>arm-linux-gcc –v</code>,会出现一堆信息，最下面一行为<code>gcc version 4.5.1 (ctng-1.8.1-FA)</code>,这说明交叉编译环境已经成功安装。</p><h2 id="编译与安装QtE-4-8-5"><a href="#编译与安装QtE-4-8-5" class="headerlink" title="编译与安装QtE-4.8.5"></a>编译与安装QtE-4.8.5</h2><h3 id="解压QtE-4-8-5"><a href="#解压QtE-4-8-5" class="headerlink" title="解压QtE-4.8.5"></a>解压QtE-4.8.5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先创建工作目录/opt/FriendlyARM/tinyc110/linux</span><br><span class="line">在命令行执行</span><br><span class="line">mkdir –p /opt/FriendlyARM/tinyc110/linux</span><br><span class="line">cd /opt/FriendlyARM/tinyc110/linux</span><br><span class="line">tar xvzf /tmp/linux/arm-qte-4.8.5-20101105.tar.gz</span><br></pre></td></tr></table></figure><h3 id="编译与安装"><a href="#编译与安装" class="headerlink" title="编译与安装"></a>编译与安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/FriendlyARM/mini210/linux/arm-qte-4.8.5</span><br><span class="line">./build.sh</span><br><span class="line">此处等待完成， 要很长时间 ，耐心一点</span><br><span class="line">./mktarget       这一步其实可以省略，执行此文件会提取出必要的 QtE-4.8.5 库文</span><br><span class="line">件 和 可 执 行 二 进 制 示 例 , 并 打 包 为 </span><br><span class="line">target-qte-4.8.5-to-devboard.tgz </span><br><span class="line">target-qte-4.8.5-to-hostpc.tgz</span><br><span class="line">如果省略,也可以直接使用我们编译好的二进制包,它们放在光盘的 Linux 目录下,名称</span><br><span class="line">target-qte-4.8.5-to-devboard.tgz </span><br><span class="line">target-qte-4.8.5-to-hostpc.tgz</span><br></pre></td></tr></table></figure><ul><li><p>其中 <code>target-qte-4.8.5-to-devboard.tgz</code> 是用于部署在开发板上的版 本,为了节省空间该版本删<br>除了开发工具只保留运行程序所需的库文件,而 <code>target-qte-4.8.5-to-hostpc.tgz</code> 则是用于安装在 PC<br>上,用来开发和编译程序的版本,带有 qmake 等 Qt 工具以及编译所需的头文件等,可用于配置<br>Qt Creator 开发工具。</p></li><li><p>安装 QtE-4.8.5 到 PC 上的方法如下:<br>把 <code>target-qte-4.8.5-to-hostpc.tgz</code> 在 PC 的根目录下解压即可,如下命令<br><code>tar xvzf target-qte-4.8.5-to-hostpc.tgz –C /</code></p></li><li><p>QtE-4.8.5 会安装到目录 <code>/usr/local/Trolltech/QtEmbedded-4.8.5-arm/</code> 下,它里面包含了运行<br>所需要的所有库文件和可执行程序。</p></li><li><p>qmake路径配置 ：<br><code>cd /usr/lib/x86_64-linux-gnu/qt-default/qtchooser/</code><br><code>vim default.conf</code> 将第一行路径替换为QTE485路径 <code>/usr/local/Trolltech/QtEmbedded-4.8.5-arm/lib</code></p></li></ul><h2 id="安装QT"><a href="#安装QT" class="headerlink" title="安装QT"></a>安装QT</h2><h3 id="Step1-1"><a href="#Step1-1" class="headerlink" title="Step1"></a>Step1</h3><p>进入下载好QT的目录， 一般在下载目录中 。给安装文件运行权限：<br><code>chmod u+x qt-opensource-linux-x64-5.10.1.run</code></p><h3 id="Step2-1"><a href="#Step2-1" class="headerlink" title="Step2"></a>Step2</h3><p>运行 <code>./qt-opensource-linux-x64-5.10.1.run</code><br>一路向下，注意   那个<code>5.10.1</code>要勾选，3.6个G的样子</p><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>QT5.10.1 安装按成后会自带QTcreator ， 打开QTcreator</p><ul><li>在菜单栏处找到<code>工具（Tools）</code> -&gt; <code>选项（options）</code> 打开options窗口 ，点击<code>构建和运行</code>   </li><li>点击<code>QT Versions</code> ，看auto （自动）栏是否检测到<code>QT 5.10.1 GCC 64bit</code> 以及<code>QT 4.8.5 in PATH(QtEmbedded-4.8.5-arm)</code> 如果没有检测到4.8.5 那么手动添加 路径为：<code>/usr/local/Trolltech/QtEmbedded-4.8.5-arm/bin/qmake</code></li><li>点击<code>编译器（compilers）</code> -&gt; <code>添加（add）</code> -&gt; <code>GCC</code> -&gt; <code>C++</code>  下方出现弹窗 ， 将一条名称改为<code>ARMGCC</code> ， 第二条路径为<code>/opt/FriendlyARM/toolschain/4.5.1/bin/arm-linux-gcc</code> ，最后点击<code>应用（apply）</code> </li><li>点击<code>构建套件（kit）</code>  ，修改名称为ARM ， 然后将才编译器 c++ ： 更换成 <code>ARMGCC</code>  ，最后点击<code>应用（apply）</code> </li></ul><blockquote><p>最后这就表示安装并且配置完成了， 可以开心的玩起来了。</p></blockquote><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>新建工程 ， 选择编译环境时把<code>ARM</code> 和 <code>Desktop</code> 都勾选起来 ，这样的话 ，我们就可以在PC上调试好， 放到开发板中运行了  。</p><ul><li>编译的时候可以在左边绿色三角上方选择编译器 ，  选择Desktop可以在PC上调试 ， 选择ARM 会生成开发板需要的执行文件 。 运行之后都会在项目所在的目录生成一个目录。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu17-10-友善6410-PC端QT开发环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu17-10-友善6410-PC端QT开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu17.10 友善6410 PC端QT开发环境搭建&quot;&gt;
      
    
    </summary>
    
      <category term="Embedded" scheme="https://hongtao-huang.github.io/categories/Embedded/"/>
    
    
      <category term="W3C MDN HTML Tag 空Tag 可替换Tag" scheme="https://hongtao-huang.github.io/tags/W3C-MDN-HTML-Tag-%E7%A9%BATag-%E5%8F%AF%E6%9B%BF%E6%8D%A2Tag/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://hongtao-huang.github.io/HTML/"/>
    <id>https://hongtao-huang.github.io/HTML/</id>
    <published>2018-03-14T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><blockquote><p>万维网联盟（W3C）由蒂姆·伯纳斯-李于1994年10月离开欧洲核子研究中心（CERN）后成立。<br>该组织试图通过W3C制定的新标准来促进业界成员间的兼容性和协议。不兼容的HTML版本由不同的供应商提供，导致网页显示方式不一致。联盟试图让所有的供应商实施一套由联盟选择的核心原则和组件。</p></blockquote><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><blockquote><p>为解决网络应用中不同平台、技术和开发者带来的不兼容问题，保障网络信息的顺利和完整流通，万维网联盟制定了一系列标准并督促网络应用开发者和内容提供者遵循这些标准。标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。W3C也制定了包括XML和CSS等的众多影响深远的标准规范。</p></blockquote><blockquote><p>但是，W3C制定的网络标准似乎并非强制而只是推荐标准。因此部分网站仍然不能完全实现这些标准。特别是使用早期所见即所得网页编辑软件设计的网页往往会包含大量非标准代码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-  -W3C推荐标准</span><br><span class="line">CSS：层叠样式表</span><br><span class="line">DOM：文档对象模型</span><br><span class="line">HTML：超文本标记语言</span><br><span class="line">RDF：资源描述框架</span><br><span class="line">SMIL：同步多媒体集成语言</span><br><span class="line">SVG：可缩放向量图形</span><br><span class="line">WAI</span><br><span class="line">Widgets</span><br><span class="line">XHTML：可扩展超文本标记语言</span><br><span class="line">XML：可扩展标记语言</span><br></pre></td></tr></table></figure><h2 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h2><ul><li>MDN Web Docs 是一个汇集众多Mozilla基金会产品和网络技术开发文档的免费网站</li><li>该项目始于2005年，最初由Mozilla公司员工Deb Richardson领导。自2006年以来，文档工作由Eric Shepherd领导</li><li><ul><li>关于前端的一些技术都可以先从MDN中搜索了解，比如一些HTML标签的使用，CSS属性的使用等</li></ul></li></ul><h2 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h2><h3 id="MDN链接"><a href="#MDN链接" class="headerlink" title="MDN链接"></a>MDN链接</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener">HTML All Tags ,MDN</a></p><h2 id="空标签"><a href="#空标签" class="headerlink" title="空标签"></a>空标签</h2><h3 id="什么是空标签？"><a href="#什么是空标签？" class="headerlink" title="什么是空标签？"></a>什么是空标签？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML，SVG 和 MathML 的规范都详细定义了每个元素能包含的具体内容（define very precisely what each element can contain）。许多组合是没有任何语义含义的，比如一个 &lt;audio&gt; 元素嵌套在一个 &lt;hr&gt; 元素里。</span><br><span class="line">在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， &lt;input type=&quot;text&quot;&gt;&lt;/input&gt; 的闭标签是无效的 HTML。</span><br></pre></td></tr></table></figure><ul><li>理解： 一个没有闭标签(或者说闭标签加了无效) 或者 HTML、SVG、MathML规范中没有定义标签能包含哪些内容的标签就是 空标签。</li></ul><h3 id="HTML中的空标签"><a href="#HTML中的空标签" class="headerlink" title="HTML中的空标签"></a>HTML中的空标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;area&gt;</span><br><span class="line">&lt;base&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;col&gt;</span><br><span class="line">&lt;colgroup&gt; when the span is present</span><br><span class="line">&lt;command&gt;</span><br><span class="line">&lt;embed&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;img&gt;</span><br><span class="line">&lt;input&gt;</span><br><span class="line">&lt;keygen&gt;</span><br><span class="line">&lt;link&gt;</span><br><span class="line">&lt;meta&gt;</span><br><span class="line">&lt;param&gt;</span><br><span class="line">&lt;source&gt;</span><br><span class="line">&lt;track&gt;</span><br><span class="line">&lt;wbr&gt;</span><br></pre></td></tr></table></figure><h2 id="可替换标签？"><a href="#可替换标签？" class="headerlink" title="可替换标签？"></a>可替换标签？</h2><h3 id="什么是可替换标签？"><a href="#什么是可替换标签？" class="headerlink" title="什么是可替换标签？"></a>什么是可替换标签？</h3><blockquote><p>可替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如浏览器会根据&lt;img&gt;标签的src属性的值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容；又例如根据&lt;input&gt;标签的type属性来决定是显示输入框，还是单选按钮等。</span><br></pre></td></tr></table></figure><h3 id="常见的几个可替换标签"><a href="#常见的几个可替换标签" class="headerlink" title="常见的几个可替换标签"></a>常见的几个可替换标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;W3C&quot;&gt;&lt;a href=&quot;#W3C&quot; class=&quot;headerlink&quot; title=&quot;W3C&quot;&gt;&lt;/a&gt;W3
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="W3C MDN HTML Tag 空Tag 可替换Tag" scheme="https://hongtao-huang.github.io/tags/W3C-MDN-HTML-Tag-%E7%A9%BATag-%E5%8F%AF%E6%9B%BF%E6%8D%A2Tag/"/>
    
  </entry>
  
  <entry>
    <title>node.js Server</title>
    <link href="https://hongtao-huang.github.io/nodejs-Server/"/>
    <id>https://hongtao-huang.github.io/nodejs-Server/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js-Server"><a href="#node-js-Server" class="headerlink" title="node.js Server"></a>node.js Server</h1><h2 id="脚本建Server"><a href="#脚本建Server" class="headerlink" title="脚本建Server"></a>脚本建Server</h2><h3 id="用什么脚本建服务器"><a href="#用什么脚本建服务器" class="headerlink" title="用什么脚本建服务器"></a>用什么脚本建服务器</h3><ul><li>用脚本就可以提供 HTTP 服务，不管是 Bash 脚本还是 Node.js 脚本都可以。</li><li>由于 Bash 脚本的语法实在是反人类，而且我们今后要学习 JavaScript，所以我们先用 Node.js 脚本试试水吧。</li><li>建成的服务器就是我们的电脑，没钱买服务器，穷逼的我们就用电脑做服务器实验吧，哈哈哈</li></ul><h3 id="创建node-js-Server脚本"><a href="#创建node-js-Server脚本" class="headerlink" title="创建node.js Server脚本"></a>创建node.js Server脚本</h3><ul><li>用bush命令操作，进个自己认为安全好用的目录</li><li>创建文件 <code>touch server.js</code> ,将以下内容加入：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)</span><br><span class="line">var port = process.argv[2]</span><br><span class="line"></span><br><span class="line">if(!port)&#123;</span><br><span class="line">  console.log(&apos;请指定端口号好不啦？\nnode server.js 8888 这样不会吗？&apos;)</span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(request, response)&#123;</span><br><span class="line">  var parsedUrl = url.parse(request.url, true)</span><br><span class="line">  var path = request.url </span><br><span class="line">  var query = &apos;&apos;</span><br><span class="line">  if(path.indexOf(&apos;?&apos;) &gt;= 0)&#123; query = path.substring(path.indexOf(&apos;?&apos;)) &#125;</span><br><span class="line">  var pathNoQuery = parsedUrl.pathname</span><br><span class="line">  var queryObject = parsedUrl.query</span><br><span class="line">  var method = request.method</span><br><span class="line"></span><br><span class="line">  /******** 从这里开始看，上面不要看 ************/</span><br><span class="line"></span><br><span class="line">  console.log(&apos;HTTP 路径为\n&apos; + path)</span><br><span class="line">  if(path == &apos;/style.css&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;body&#123;background-color: #ddd;&#125;h1&#123;color: red;&#125;p&#123;color: green;&#125;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/main.js&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;alert(&quot;这是JS执行的&quot;)&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else if(path == &apos;/&apos;)&#123;</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;&lt;!DOCTYPE&gt;\n&lt;html&gt;&apos;  + </span><br><span class="line">      &apos;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;&apos; +</span><br><span class="line">      &apos;&lt;/head&gt;&lt;body&gt;&apos;  +</span><br><span class="line">      &apos;&lt;h1&gt;你好&lt;/h1&gt;&apos; +</span><br><span class="line">      &apos;&lt;p&gt;这里是你访问到的内容，字体的颜色为你访问到的css添加&lt;/p&gt;&apos;+</span><br><span class="line">      &apos;&lt;script src=&quot;/main.js&quot;&gt;&lt;/script&gt;&apos; +</span><br><span class="line">      &apos;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /******** 代码结束，下面不要看 ************/</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(port)</span><br><span class="line">console.log(&apos;监听 &apos; + port + &apos; 成功\n请用在空中转体720度然后用电饭煲打开 http://localhost:&apos; + port)</span><br></pre></td></tr></table></figure><ul><li>运行 <code>node server.js</code> ,如果开始创建文件没有加后缀就运行 <code>node server</code> ,会看到报错<br>  <img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpbmpoffrjj308002aweh.jpg" alt=""><br>  没有监听端口那我们就 <code>node server 8888</code></li><li>成功之后，这个 server 会保持运行(相当于服务器开始运行了，可以接受请求了)，无法退出<ul><li>如果你想「中断」这个 server，按 <kb>Ctrl + <kbd>C</kbd> 即可（C 就是 Cancel 的意思）</kb></li><li>中断后你才能输入其他命令</li><li>我建议你把这个 server 放在那里别动，新开一个 Bash 窗口，完成下面的教程</li></ul></li></ul><h3 id="服务器当前的功能"><a href="#服务器当前的功能" class="headerlink" title="服务器当前的功能"></a>服务器当前的功能</h3><ol><li>这个服务器目前只有一个功能，那就是打印出路径</li><li>发出响应，返回一个页面</li></ol><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><ul><li>使用bush 或者 浏览器 向我们这个服务器发起请求 ，那么服务器的地址是什么？  <blockquote><p>服务器的地址当然就是我们的本地地址啦 ，<code>http://127.0.0.1</code> 或者 <code>http://localhost</code> 发起访问： 报错<br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpbn1ddvzmj30f70ffdg5.jpg" alt="">    </p></blockquote></li></ul><ul><li>我们还是忘记了，http 访问 必须 IP + 端口号 ，所以，我们重新访问 <code>http://127.0.0.1:8888</code><br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpbnfc8nsaj30p505haaa.jpg" alt=""></li></ul><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>可以看到服务器响应给我们了一个页面， 有HTML内容的显示，css样式的加持，JS动态的弹窗</p><ul><li>同时 服务器打印出请求的路径<br><img src="http://ww1.sinaimg.cn/large/006WOZytgy1fpbnj1w33ej30bt03074h.jpg" alt=""></li></ul><h3 id="我们需要知道的"><a href="#我们需要知道的" class="headerlink" title="我们需要知道的"></a>我们需要知道的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&apos;Content-Type&apos;, &apos;text/css; charset=utf-8&apos;)  //设置响应内容的类型，以及响应内容的编码方式，返回                                                                  //css文件 </span><br><span class="line">response.setHeader(&apos;Content-Type&apos;, &apos;text/javascript; charset=utf-8&apos;) //返回js文件</span><br><span class="line">response.setHeader(&apos;Content-Type&apos;, &apos;text/html; charset=utf-8&apos;)     //返回html文件</span><br><span class="line"> response.statusCode = 404                   //返回状态码</span><br><span class="line">response.write(&apos;Hi&apos;)          //响应内容</span><br><span class="line">response.end()             //响应结束</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node-js-Server&quot;&gt;&lt;a href=&quot;#node-js-Server&quot; class=&quot;headerlink&quot; title=&quot;node.js Server&quot;&gt;&lt;/a&gt;node.js Server&lt;/h1&gt;&lt;h2 id=&quot;脚本建Server&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Server client 请求 响应" scheme="https://hongtao-huang.github.io/tags/Server-client-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTP访问要素:IP与端口</title>
    <link href="https://hongtao-huang.github.io/HTTP%E8%A6%81%E7%B4%A0%EF%BC%9AIP%20%E4%B8%8E%20%E7%AB%AF%E5%8F%A3/"/>
    <id>https://hongtao-huang.github.io/HTTP要素：IP 与 端口/</id>
    <published>2018-03-13T15:00:00.000Z</published>
    <updated>2018-09-29T13:59:08.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP访问要素-IP与端口"><a href="#HTTP访问要素-IP与端口" class="headerlink" title="HTTP访问要素:IP与端口"></a>HTTP访问要素:IP与端口</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li>HTTP 协议的底层其实是由 TCP 协议和 IP 协议（简称 TCP/IP）构建的。</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP : 传输控制协议（Transmission Control Protocol）<br>本文重点不讲TCP，可以了解下面两条概念：</li></ul><ol><li><a href="https://www.nowcoder.com/questionTerminal/63c8b45c91a544bd8febc1f1ff02e3b5?toCommentId=73766" target="_blank" rel="noopener">TCP 和 UDP 的区别是什么?</a><br>简答：<br>TCP ：可靠 、 面向连接、  相对UDP较慢。<br>UDP ：不可靠、 不面向连接、 相对TCP较快。</li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">TCP 的三次握手指的是什么？</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端：我要连接你了，可以吗</span><br><span class="line">2. 服务端：嗯，我准备好了，连接我吧</span><br><span class="line">3. 客户端：那我连接你咯。</span><br><span class="line">4. 开始后面步骤</span><br></pre></td></tr></table></figure></li></ol><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><ul><li>IP ： 网络协议（英语：Internet Protocol）  </li></ul><h3 id="内网IP-："><a href="#内网IP-：" class="headerlink" title="内网IP ："></a>内网IP ：</h3><p>假如家里有一台路由器 ，手机电脑IPAD等都连接路由器 ，而路由器给这些设备分配的IP地址就是内网IP地址。<br>一般内网IP格式为192.168.xxx.xxx 。<br>而通常路由器分给自己的内网IP是192.168.1.1 。如果不是就说明这个路由器的设置不是大众化的这种！<br>所以路由分给手机的内网IP<code>可能</code>为192.168.1.2  ，分给电脑的内网IP<code>可能</code>为192.168.1.3  </p><h3 id="外网IP-："><a href="#外网IP-：" class="headerlink" title="外网IP ："></a>外网IP ：</h3><p>如果路由器连上电信的服务器，那么路由器就会有一个外网IP 。<br>外网IP格式 ： 暂时理解为只要不是192.168开头的就都是外网IP ，可能理解有误。<br>如果路由器重启 ，则很有<code>可能</code>被重新分配一个外网IP ，也就是说路由器没有固定的外网IP。</p><h3 id="内外网的访问"><a href="#内外网的访问" class="headerlink" title="内外网的访问"></a>内外网的访问</h3><ol><li>内网可以直接访问外网么？<br>答案是<code>不能</code>，内网IP访问外网必须要通过路由器来中转 ，路由器只有连上了电信服务器，分配有外网IP才能访问外网。  </li><li>路由器的作用是什么，什么是路由？<br>比如说我们手机要访问baidu.com  ，必须先经过路由中转然后路由外网IP对baidu.com 发送请求，百度收到后对路由响应一个网页或者  数据之类的东东。<br>路由器接收到 baidu.com 的页面后，把页面发送给你的电脑或手机。路由器知道如何给这些信息指路，路由器就是一个指路人，这就是「路由」两个字的来历。<br>路，就是「必由之路」中的路。由，就是「必由之路」中的由（由是经过、缘由的意思）。所有的信息都要经过路由器，然后被指向一条它该去的路。<br>也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器（因为路由器既有外网 IP 也有内网 IP），所以路由器有时候也被叫做「网关」，这个「关」是「一夫当关，万夫莫开」的「关」。如果路由器到电信的连接中断了，那么内网中所有的设备也就无法上网了。（这很好理解，相当于唯一一条出去的路断了）  </li><li>内网能访问内网么？<br>内网中的设备可以互相访问（比如你可以用电脑或手机进入 <a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a> 来查看你的路由器），但是不能直接访问外网，内网设备想要访问外网，就必须经过路由器中转。  </li><li>外网能访问外网么？<br>外网中的设备可以互相访问（比如 qq.com 可以把首页发送给你的路由器，你的路由器有外网 IP），但是外网中的设备无法访问你的内网设备（这很好理解，内网是一个封闭的网络，外人进不来，所以实际上 qq.com 无法直接把首页放送给你的电脑和手机</li></ol><h3 id="本地IP"><a href="#本地IP" class="headerlink" title="本地IP"></a>本地IP</h3><p>这是一个特殊的IP ，代表着设备自己的IP。<br>默认情况下，hosts 文件里会有一行127.0.0.1 localhost，意思就是 localhost 指向 127.0.0.1，所以 localhost 也表示设备自己。不信你 <code>ping localhost</code> 试试，会发现实际上是在 <code>ping 127.0.0.1</code></p><h3 id="特殊IP"><a href="#特殊IP" class="headerlink" title="特殊IP"></a>特殊IP</h3><p>IP：0.0.0.0，它不表示任何设备。这个 IP 不同的地方含义不同。</p><h2 id="端口（Port）"><a href="#端口（Port）" class="headerlink" title="端口（Port）"></a>端口（Port）</h2><p>你想要访问一个设备（前提是你使用的是 TCP 或 UDP 协议。还记得吗，HTTP 就使用了 TCP），只指定 IP 是不够的，必须指定端口。<br>端口其实就是一个编号，并不是一种硬件。<br>一个服务器（硬件）不一定只提供一种服务，比如一个服务器既提供 HTTP 服务，又提供 FTP 服务，还提供 SMTP 服务（邮件服务），那么只用一个 IP 是无法告诉服务器你想要使用哪种服务。<br>所以这里有一个重要的原则：一个端口对应一个服务。<br>比如  </p><ol><li>要提供 HTTP 服务你最好使用 80 端口（能不能使用别的端口？可以，不过不建议你违反约定）</li><li>要提供 HTTPS 服务你最好使用 443 端口（能不能使用别的端口？可以，不过不建议你违反约定）</li><li>要提供 FTP 服务你最好使用 21 端口（能不能使用别的端口？可以，不过不建议你违反约定）</li></ol><h3 id="我怎么知道应该使用什么端口？"><a href="#我怎么知道应该使用什么端口？" class="headerlink" title="我怎么知道应该使用什么端口？"></a>我怎么知道应该使用什么端口？</h3><p><a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8#0.E5.88.B01023.E5.8F.B7.E7.AB.AF.E5.8F.A3" target="_blank" rel="noopener">维基百科</a> 把 0 到 1023 号端口对应的服务都告诉你了，点进去看看吧。  </p><h3 id="一共有多少端口？"><a href="#一共有多少端口？" class="headerlink" title="一共有多少端口？"></a>一共有多少端口？</h3><p>每个机器一共有 65535（2的16次方减1）个端口（这是协议规定的）。不过这些端口的使用由一些规定：  </p><ol><li>0 到 1023（2的10次方减1）号端口是留给系统使用的，你只有拥有了管理员权限后，才能使用这 1024 个端口。</li><li>其他端口可以给普通用户使用</li><li>如果一个端口正在提供服务，也就是被占用了，那么就不能再使用这个端口。除非你先停掉正在占用这个端口的服务。以后你们会经常遇到这个问题。</li></ol><h2 id="TCP-IP总结"><a href="#TCP-IP总结" class="headerlink" title="TCP/IP总结"></a>TCP/IP总结</h2><p>上面都是 TCP/IP 相关的知识，如果你记不住，就记住下面这句话：</p><blockquote><p>使用 HTTP 协议访问另一个 IP 时，比如同时提供 IP 和端口号，缺一不可。</p></blockquote><ul><li>那么问题来了</li></ul><p>我访问 <a href="http://qq.com" target="_blank" rel="noopener">http://qq.com</a> 时并没有提供端口号，为什么我依然可以访问</p><blockquote><p>答：因为浏览器帮你加了默认端口号 80。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP访问要素-IP与端口&quot;&gt;&lt;a href=&quot;#HTTP访问要素-IP与端口&quot; class=&quot;headerlink&quot; title=&quot;HTTP访问要素:IP与端口&quot;&gt;&lt;/a&gt;HTTP访问要素:IP与端口&lt;/h1&gt;&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#H
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="TCP IP UDP HTTP 端口 内网  外网" scheme="https://hongtao-huang.github.io/tags/TCP-IP-UDP-HTTP-%E7%AB%AF%E5%8F%A3-%E5%86%85%E7%BD%91-%E5%A4%96%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://hongtao-huang.github.io/http/"/>
    <id>https://hongtao-huang.github.io/http/</id>
    <published>2018-03-11T15:45:50.000Z</published>
    <updated>2018-09-29T13:59:08.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><code>URL</code> 俗称网址 ， 也就是统一资源<code>定位</code>符/<code>定位</code>地址</p><h3 id="URL-的组成"><a href="#URL-的组成" class="headerlink" title="URL 的组成"></a>URL 的组成</h3><p><a href="https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#1" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#1</a></p><p><code>https</code> 为超文本传输协议，两个电脑之间传输内容的协议 。也就是说前面的<code>http</code> 或者 <code>https</code>指的是协议</p><p><code>www.baidu.com</code> 域名 </p><p><code>/s</code> 路径， 这个路径非计算机中文件路径。 <code>https://www.baidu.com</code> 这个网址默认会有一个 <code>/</code>的路径</p><p><code>wd=hello&amp;rsv_spt=1</code> 查询参数 ，可以点击 <a href="https://www.baidu.com/s?wd=hi&amp;rsv_spt=1#1" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hi&amp;rsv_spt=1#1</a> 会发现变成了在百度hi的内容</p><p><code>#1</code> 锚点 ， 将网站#1 变为 #3 ，点击 <a href="https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#3" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#3</a> 会发现直接显示在第一行的是该搜索项网页的第三个链接 ，多次修改#后面的数字就会明白了</p><p><code>:80</code> 其实这个网址还有一个端口号，http协议的服务端口号就是对应的80。<a href="https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#1:80" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#1:80</a> 这个网址的效果和 <a href="https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#1是一样的。" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hello&amp;rsv_spt=1#1是一样的。</a></p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><blockquote><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP<br>地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p></blockquote><blockquote><p>例如，<a href="http://www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以" target="_blank" rel="noopener">www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以</a><br>直接拨打wikipedia的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字<br>（如<a href="http://www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。[1]" target="_blank" rel="noopener">www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。[1]</a></p></blockquote><ul><li>简单理解就是，DNS 可以把 域名 转换为IP地址 </li></ul><h3 id="两种查看域名对应IP地址的方法"><a href="#两种查看域名对应IP地址的方法" class="headerlink" title="两种查看域名对应IP地址的方法"></a>两种查看域名对应IP地址的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nslookup baidu.com</span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="请求百度页面"><a href="#请求百度页面" class="headerlink" title="请求百度页面"></a>请求百度页面</h3><p><img src="//video.jirengu.com/FsfB2P_WlfvCBOfU2vUARSL0AmCg" alt="请求"><br>访问百度网站   ，我们点击第一个，然后点Request  右边的view<br><img src="//video.jirengu.com/FlXCfBPkgLIkBd4ceo1wubiB-K9k" alt="图片"></p><p>请求的格式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 动词 路径 协议/版本</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line">3 </span><br><span class="line">4 要上传的数据</span><br></pre></td></tr></table></figure></p><p>###分析请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1                        动词 路径 协议/版本</span><br><span class="line">Host: www.baidu.com               key1</span><br><span class="line">Connection: keep-alive             key2</span><br><span class="line">Cache-Control: max-age=0      key3</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><ol><li>请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）</li><li>第三部分永远都是一个回车（\n）</li><li>动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等<br> i. GET就是获取的意思<br>ii. POST 就是上传的意思， 上传信息会有一个content-length ： 上传的数据长度 ，然后第四部分会有上传信息的内容<br>iii. </li><li>这里的路径包括「查询参数」，但不包括「锚点」</li><li>如果你没有写路径，那么路径默认为 /</li><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式</li><li>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</li></ol><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="有请求就有响应，下面是百度的响应"><a href="#有请求就有响应，下面是百度的响应" class="headerlink" title="有请求就有响应，下面是百度的响应"></a>有请求就有响应，下面是百度的响应</h3><p><img src="//video.jirengu.com/FqFw99ah9wk45yKcfF5TKwrqIwI5" alt="查看 Response Headers，点击「view source」，点击「view source]"></p><ul><li>GET 请求和 POST 请求对应的响应可以一样，也可以不一样</li><li>响应的第四部分可以很长很长很长</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Bdpagetype: 2</span><br><span class="line">Bdqid: 0x8f2fe8e100013131</span><br><span class="line">Bduserid: 941701595</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Date: Mon, 12 Mar 2018 14:49:48 GMT</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>响应的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure></p><ul><li>状态码要背，是服务器对浏览器说的话 ,每个记到6就好了 ，想多记可以搜HTTP状态码，看维基百科<ul><li>1xx 不常用<blockquote><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。[4] 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p></blockquote></li><li>2xx 表示成功<blockquote><p>200 OK<br>请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>201 Created<br>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。<br>202 Accepted<br>服务器已接受请求，但尚未处理。<br>203 Non-Authoritative Information（自HTTP / 1.1起<br>服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。<br>204 No Content<br>服务器成功处理了请求，没有返回任何内容<br>205 Reset Content<br>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。<br>206 Partial Content<br>服务器已经成功处理了部分GET请求。</p></blockquote></li><li>3xx 表示滚吧<blockquote><p>300 Multiple Choices<br>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>301 Moved Permanently:<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。<br>302 Found<br>要求客户端执行临时重定向 ,服务器临时换了个地址<br>303 See Other<br>对应当前请求的响应可以在另一个 URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。<br>304 Not Modified<br>表示资源未被修改，因为请求头指 定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。<br>305 Use Proxy<br>被请求的资源必须通过指定的代理才能被访问。<br>306 Switch Proxy<br>在最新版的规范中，306状态码已经不再被使用。</p></blockquote></li><li>4xx 表示你丫错了<blockquote><p>400 Bad Request<br>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。<br>401 Unauthorized<br>类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。[32]该状态码表示当前请求需要用户验证。<br>402 Payment Required<br>该状态码是为了将来可能的需求而预留的。<br>403 Forbidden<br>服务器已经理解请求，但是拒绝执行它。<br>404 Not Found<br>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。<br>405 Method Not Allowed<br>请求行中指定的请求方法不能被用于请求相应的资源。<br>406 Not Acceptable<br>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。</p></blockquote></li><li>5xx 表示好吧，我错了<blockquote><p>500 Internal Server Error<br>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。<br>501 Not Implemented<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。<br>502 Bad Gateway<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>503 Service Unavailable<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。<br>504 Gateway Timeout<br>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>505 HTTP Version Not Supported<br>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。<br>506 Variant Also Negotiates（RFC 2295）<br>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，[64]被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p></blockquote></li></ul></li><li>状态解释没什么用</li><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式</li><li>第 2 部分中的 Content-Type 遵循 MIME 规范</li><li><ul><li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h2 id=&quot;URL&quot;&gt;&lt;a href=&quot;#URL&quot; class=&quot;headerlink&quot; title=&quot;URL&quot;&gt;&lt;/a&gt;UR
      
    
    </summary>
    
      <category term="前端" scheme="https://hongtao-huang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="URL  请求  响应  URL  http协议 curl" scheme="https://hongtao-huang.github.io/tags/URL-%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94-URL-http%E5%8D%8F%E8%AE%AE-curl/"/>
    
  </entry>
  
</feed>
